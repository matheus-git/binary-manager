mod loaders;
pub mod types;
pub mod printers;

use std::fmt::format;

use loaders::load_elf64_header::LoadELF64Header;
use loaders::load_elf64_program_header::LoadELF64ProgramHeader;
use loaders::load_elf64_section_header::LoadELF64SectionHeader;

use types::elf64_header::Elf64Header;
use types::elf64_program_header::Elf64ProgramHeader;
use types::elf64_section_header::Elf64SectionHeader;
use crate::traits::binary::Binary;
use crate::traits::header_field::HeaderField;
use crate::utils::endian::Endian;
use crate::utils::string_until_null::string_until_null;

fn parse_program_headers(buf: &[u8], elf_header: &Elf64Header, endian: &Endian) -> Vec<Elf64ProgramHeader> {
    let mut headers = Vec::with_capacity(elf_header.e_phnum.value as usize);

    for i in 0..elf_header.e_phnum.value as usize {
        let start = elf_header.e_phoff.value as usize + i * elf_header.e_phentsize.value as usize;
        let end = start + elf_header.e_phentsize.value as usize;

        let raw_header = LoadELF64ProgramHeader::from_bytes(&buf[start..end]);
        headers.push(Elf64ProgramHeader::new(raw_header, endian));
    }

    headers
}

fn parse_section_headers(buf: &[u8], elf_header: &Elf64Header, endian: &Endian) -> Vec<Elf64SectionHeader> {
    let mut headers = Vec::with_capacity(elf_header.e_shnum.value as usize);

    for i in 0..elf_header.e_shnum.value as usize {
        let start = elf_header.e_shoff.value as usize + i * elf_header.e_shentsize.value as usize;
        let end = start + elf_header.e_shentsize.value as usize;

        let raw_header = LoadELF64SectionHeader::from_bytes(&buf[start..end]);
        headers.push(Elf64SectionHeader::new(raw_header, endian));
    }

    headers
}

fn resolve_section_name(section_headers: &mut Vec<Elf64SectionHeader>, buf: &[u8], elf_header: &Elf64Header, endian: &Endian){
    let strtab_section = &section_headers[elf_header.e_shstrndx.value as usize ];
    let strtab_section_offset = endian.read_u64(strtab_section.sh_offset.raw);

    for section in section_headers {
        let name_index = section.sh_name.value;
        let name = string_until_null(&buf[(strtab_section_offset as usize + name_index as usize)..]);
        section.sh_name.update_name(name.to_string());
    }
}

#[derive(Debug)]
pub struct Elf64Binary {
    header: Elf64Header,
    program_headers: Vec<Elf64ProgramHeader>,
    section_headers: Vec<Elf64SectionHeader>,
    pub raw: Vec<u8>
}

impl Elf64Binary {
    pub fn new(buf: &[u8]) -> Self{
        let load_elf_header =  LoadELF64Header::from_bytes(buf);
        let elf_header = Elf64Header::new(load_elf_header);
        let endian: Endian = elf_header.e_ident.endian();
        
        let program_headers = parse_program_headers(buf, &elf_header, &endian);
        let mut section_headers = parse_section_headers(buf, &elf_header, &endian);

        resolve_section_name(&mut section_headers, buf, &elf_header, &endian);

        Self { 
            header: elf_header, 
            program_headers,
            section_headers,
            raw: buf.to_vec()
        }
    }

    pub fn inject(&mut self, buf: Vec<u8>) -> Vec<u8> {
        let mut injected: Vec<u8> = self.into();
        const NEW_ADDR = u64::from_str_radix("80000", 16).expect("failed"); 
         
        let endian = self.header.e_ident.endian();

        let note_offset = self.section_headers
            .iter()
            .find(|s| s.sh_name.name == ".note.ABI-tag")
            .map(|s| s.sh_offset.raw);

        let Some(note_offset) = note_offset else {
            println!(".note.ABI-tag not found");
            return Vec::new();
        };

        if let Some(program) = self.program_headers
            .iter_mut()
            .find(|p| p.p_offset.raw == note_offset)
        {
            println!("Program header encontrado com offset {:?}", program.p_offset.describe());
            program.p_offset.raw = [41, 1, 45, 0, 0, 0, 0, 0];
            let n: i32 = (injected.len() % 4096) as i32 - (endian.read_u64(program.p_vaddr.raw) % 4096) as i32;
            println!("{}{n}",endian.read_u64(program.p_vaddr.raw));
            injected.extend_from_slice(&[0,0]);
        } else {
            println!("Program header correspondente nÃ£o encontrado!");
            return Vec::new();
        }

        self.into()
    }
}

impl Binary for Elf64Binary {
    type Header = Elf64Header;
    type ProgramHeader = Elf64ProgramHeader;
    type SectionHeader = Elf64SectionHeader;

    fn get_header(&self) -> &Self::Header {
        &self.header
    }

    fn get_program_headers(&self) -> &[Self::ProgramHeader] {
        &self.program_headers
    }

    fn get_section_headers(&self) -> &[Self::SectionHeader] {
        &self.section_headers
    }
}

impl From<&Elf64Binary> for Vec<u8> {
    fn from(h: &Elf64Binary) -> Vec<u8> {
        let mut bytes = h.raw.clone();

        let header_bytes: Vec<u8> = (&h.header).into();
        bytes[0..header_bytes.len()].copy_from_slice(&header_bytes);

        for (i, ph) in h.program_headers.iter().enumerate() {
            let ph_bytes: Vec<u8> = ph.into();
            let offset = h.header.e_phoff.value as usize + i * h.header.e_phentsize.value as usize;
            bytes[offset..offset + ph_bytes.len()].copy_from_slice(&ph_bytes);
        }

        for (i, sh) in h.section_headers.iter().enumerate() {
            let sh_bytes: Vec<u8> = sh.into();
            let offset = h.header.e_shoff.value as usize + i * h.header.e_shentsize.value as usize;
            bytes[offset..offset + sh_bytes.len()].copy_from_slice(&sh_bytes);
        }

        bytes
    }
}

impl From<&mut Elf64Binary> for Vec<u8> {
    fn from(h: &mut Elf64Binary) -> Vec<u8> {
        let mut bytes = h.raw.clone();

        let header_bytes: Vec<u8> = (&h.header).into();
        bytes[0..header_bytes.len()].copy_from_slice(&header_bytes);

        for (i, ph) in h.program_headers.iter().enumerate() {
            let ph_bytes: Vec<u8> = ph.into();
            let offset = h.header.e_phoff.value as usize + i * h.header.e_phentsize.value as usize;
            bytes[offset..offset + ph_bytes.len()].copy_from_slice(&ph_bytes);
        }

        for (i, sh) in h.section_headers.iter().enumerate() {
            let sh_bytes: Vec<u8> = sh.into();
            let offset = h.header.e_shoff.value as usize + i * h.header.e_shentsize.value as usize;
            bytes[offset..offset + sh_bytes.len()].copy_from_slice(&sh_bytes);
        }

        bytes
    }
}
